[f] @Consumers --> @Receives
  --> note that it shouldn't be useful in most cases as content types transit with messages
[f] @Produces --> @Sends (allow array of values like Jersey?)
[x] gather message data into an Event object?
[x] body converters (reader/writer in Jersey)
  --> driven by content type
  [x] interface ==> using MessageBodyReader/Writer
  [x] injection
  [x] String using encoding
  [x] bytes
  [x] JSON
    [x] Jackson by default
      [x] use injected ObjectMapper
[ ] parameter providers
  [ ] they should be available to normal injection (i.e. Guice) too somehow
    --> requires an InjectableProvider that is a factory of Injectables that are providers for specific events
  [x] body (with the help of body converters)
  [ ] AMQP.BasicProperties
  [ ] Channel
  [ ] @BindingKeyParam
  [ ] properties params
    [ ] @ContentType
    [ ] delivery tag (necessary for ack)
  [ ] headers
  [ ] Event
  [x] Qarrot
  [ ] should we pass Qarrot or some "simpler" facade interface?
[ ] RPCs
  [x] can we return null values? ==> yes for JSON
    [f] try specifying null values by adding the "null" parameter to the media type
      --> only allowing null for media type converters that support it (in general, would be when
          body empty or some ad hoc condition)
  [ ] if method returns "void", return null
  [x] if method throws Exception, try to create an instance of the return type (if some payload object class)
    with a the (String, Throwable) constructor
    ==> returning a special error object with the same media type decorated with an "error" parameter
  [f] if no such constructor exists, return a RpcError as JSon with a "application/error" MIME type
  [ ] provide media type with response
[ ] route spec parser
[ ] auto-reconnect
  [ ] publish
  [ ] consume
[ ] allow persistence of published messages (for when RabbitMQ is not around) --> MessageStorage?
[ ] thread-safety of Qarrot and friends
[ ] look into an event custom-scope for Guice
[ ] AMQP shutdown
[ ] disconnections
  [ ] client
  [ ] server (see also persistence of messages)
[x] use stuff from JAX-RS and simplify
[ ] scan parent injectors
[x] our RuntimeDelegateImpl is going to create problems when integrating with Jersey (or other implementations)
  --> one possibility is to transfer it into a separate project
[ ] a RPC call that detects the MediaType (with JSON as the default for objects)
[ ] see what are the options to avoid dragging Guice into the arena by default
  --> could do something like Jersey Application
[x] test injection of ObjectMappers
[ ] we shouldn't have to call configure if we don't have any module to provide
[ ] allow to specify clients as proxied interfaces
  public interface MyClient {
    @RouteOut("exch")
    void sendUpdate(Update update);
    @RouteOut("==rpc_queue")
    Result callRpc(String param1, int param2);
  }
[ ] support for chunked content (special media type?)
[ ] support for multipart?
[x] support for array content[]? ==> not compatible for JSON... custom readers/writers can handle that
[ ] could provide AMQP Properties and/or its headers as a header multivalue map to readers and writers
[ ] split in subprojects
  - qarrot-injection: abstraction (as simple as possible) allowing to use different injection framework
  - qarrot-guice: implementation of qarrot-injection based on Guice
  - qarrot-core: most of Qarrot
  [x] qarrot-jaxrs: stub MediaTypeHeaderDelegate, META-INF stub elements that prevent to use jax-rs without stuff like
    the Jersey libraries (would be imported as test-runtime for instance)
[ ] MediaTypeHeaderDelegate
  [ ] support quoted param values
  [ ] unit tests
[ ] ChatServer example
  [ ] @Path support
    [ ] an endpoint is any class/instance that has a method annotated with @Consumes/@Produces/@Path/@RouteIn/@RouteOut
  [ ] sub-resource support